---
navigation.icon: uil:moon-eclipse
description: Nuxt leverages Vue's Transition component to apply transitions between pages and layouts.
---

# Data fetching

> Nuxt comes with two composables and a built-in library to perform data-fetching in browser or server environments: `useFetch`, [`useAsyncData`](/docs/api/composables/use-async-data) and `$fetch` . In a nutshell:

Nuxt には、ブラウザーまたはサーバー環境でデータフェッチを実行するための 2 つのコンポーザブルと組み込みライブラリ (`useFetch`、[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data)、および `$fetch`) が付属しています。 。 一言で言えば：

> - [`useFetch`](/docs/api/composables/use-fetch) is the most straightforward way to handle data fetching in a component setup function.
> - [`$fetch`](/docs/api/utils/dollarfetch) is great to make network requests based on user interaction.
> - [`useAsyncData`](/docs/api/composables/use-async-data), combined with `$fetch`, offers more fine-grained control.

- [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) は、コンポーネント セットアップ関数でデータのフェッチを処理する最も簡単な方法です。
- [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) は、ユーザー操作に基づいてネットワーク リクエストを行うのに最適です。
- [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) を `$fetch` と組み合わせると、よりきめ細かい制御が可能になります。

> Both `useFetch` and `useAsyncData` share a common set of options and patterns that we will detail in the last sections.

`useFetch` と `useAsyncData` は両方とも、最後のセクションで詳しく説明するオプションとパターンの共通セットを共有します。

> Before that, it's imperative to know why these composables exist in the first place.

その前に、そもそもこれらのコンポーザブルが存在する理由を知ることが不可欠です。

## Why using specific composables? 特定のコンポーザブルを使用する理由は何ですか?

> When using a framework like Nuxt that can perform calls and render pages on both client and server environments, some challenges must be addressed. This is why Nuxt provides composables to wrap your queries, instead of letting the developer rely on `$fetch` calls alone.

クライアント環境とサーバー環境の両方で呼び出しを実行してページをレンダリングできる Nuxt のようなフレームワークを使用する場合、いくつかの課題に対処する必要があります。 これが、開発者が `$fetch` 呼び出しだけに依存するのではなく、Nuxt がクエリをラップするコンポーザブルを提供する理由です。

### Network calls duplication ネットワーク通話の重複

> The [`useFetch`](/docs/api/composables/use-fetch) and [`useAsyncData`](/docs/api/composables/use-async-data) composables ensure that once an API call is made on the server, the data is properly forwarded to the client in the payload.

[`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) および [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) コンポーザブルは、サーバー上で API 呼び出しが行われると、 、データはペイロードでクライアントに適切に転送されます。

> The payload is a JavaScript object accessible through [`useNuxtApp().payload`](/docs/api/composables/use-nuxt-app#payload). It is used on the client to avoid refetching the same data when the code is executed in the browser.

ペイロードは、[`useNuxtApp().payload`](https://nuxt.com/docs/api/composables/use-nuxt-app#payload) を通じてアクセスできる JavaScript オブジェクトです。 これは、コードがブラウザーで実行されるときに同じデータの再フェッチを避けるためにクライアントで使用されます。

::alert{icon=⚙️}
Use the [Nuxt DevTools](https://devtools.nuxt.com) to inspect this data in the payload tab.
::

[Nuxt DevTools](https://devtools.nuxt.com) を使用して、ペイロード タブでこのデータを検査します。

### Suspense

> Nuxt uses Vue’s [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense) component under the hood to prevent navigation before every async data is available to the view. The data fetching composables can help you leverage this feature and use what suits best on a per-calls basis.

Nuxt は、Vue の [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense) コンポーネントを内部で使用して、すべての非同期データがビューで利用可能になる前にナビゲーションを防止します。 データ取得コンポーザブルは、この機能を活用し、呼び出しごとに最適なものを使用するのに役立ちます。

> These composables are auto-imported and can be used in `setup` functions or lifecycle hooks

これらのコンポーザブルは自動インポートされ、「セットアップ」関数またはライフサイクル フックで使用できます。

## `useFetch`

> The [`useFetch`](/docs/api/composables/use-fetch) composable is the most straightforward way to perform data fetching.

[`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) コンポーザブルは、データ フェッチを実行する最も簡単な方法です。

```vue [app.vue]
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  Page visits: {{ count }}
</template>
```

This composable is a wrapper around the [`useAsyncData`](/docs/api/composables/use-async-data) composable and `$fetch` utility.

> このコンポーザブルは、[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) コンポーザブルおよび `$fetch` ユーティリティのラッパーです。

[ReadMore](https://nuxt.com/docs/api/composables/use-fetch)

[LinkExample](https://nuxt.com/docs/examples/features/data-fetching)

## `$fetch`

> Nuxt includes the `ofetch` library, and is auto-imported as the `$fetch` alias globally across your application. It's what `useFetch` uses behind the scenes.

Nuxt には `ofetch` ライブラリが含まれており、`$fetch` エイリアスとしてアプリケーション全体にグローバルに自動インポートされます。 これは `useFetch` が舞台裏で使用するものです。

```ts
const users = await $fetch('/api/users').catch((error) => error.data)
```

> Beware that using only `$fetch` will not provide [network calls de-duplication and navigation prevention](#why-using-specific-composables). It is recommended to use `$fetch` when posting data to an event handler, when doing client-side only logic, or combined with `useAsyncData`.

`$fetch` のみを使用すると、[ネットワーク呼び出しの重複排除とナビゲーションの防止](#why-using-specific-composables) が提供されないことに注意してください。 イベント ハンドラーにデータを送信するとき、クライアント側のみのロジックを実行するとき、または `useAsyncData` と組み合わせて`$fetch` を使用することをお勧めします。

The `ofetch` library is built on top of [the `fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) and adds handy features to it:

- Works the same way in browser, Node or worker environments
- Automatic response parsing
- Error handling
- Auto-retry
- Interceptors

> [Read the full documentation of ofetch](https://github.com/unjs/ofetch)

[ofetch の完全なドキュメントを読む](https://github.com/unjs/ofetch)

[ReadMore](https://nuxt.com/docs/api/utils/dollarfetch)

## `useAsyncData`

> The `useAsyncData` composable is responsible for wrapping async logic and returning the result once it is resolved.

`useAsyncData` コンポーザブルは、非同期ロジックをラップし、解決された後に結果を返す役割を果たします。

> Indeed, `useFetch(url)` is nearly equivalent to `useAsyncData(url, () => $fetch(url))` - it's developer experience sugar for the most common use case.

実際、「useFetch(url)」は「useAsyncData(url, () => $fetch(url))」とほぼ同等であり、最も一般的な使用例の開発者エクスペリエンスに最適です。

> There are some cases when using the [`useFetch`](/docs/api/composables/use-fetch) composable is not appropriate, for example when a CMS or a third-party provide their own query layer. In this case, you can use [`useAsyncData`](/docs/api/composables/use-async-data) to wrap your calls and still keep the benefits provided by the composable.

[`useFetch`](/docs/api/composables/use-fetch) コンポーザブルの使用が適切でない場合があります。たとえば、CMS やサードパーティが独自のクエリ レイヤーを提供している場合などです。 この場合、[`useAsyncData`](/docs/api/composables/use-async-data) を使用して呼び出しをラップし、コンポーザブルによって提供される利点を維持できます。

> The first argument of [`useAsyncData`](/docs/api/composables/use-async-data) is the unique key used to cache the response of the second argument, the querying function. This argument can be ignored by directly passing the querying function. In that case, it will be auto-generated.

[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) の最初の引数は、2 番目の引数であるクエリ関数の応答をキャッシュするために使用される一意のキーです。 この引数は、クエリ関数を直接渡すことで無視できます。 その場合は自動生成されます。

```ts
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))
```

> Since the autogenerated key only takes into account the file and line where `useAsyncData` is invoked, is recommended to always create your own key to avoid unwanted behavior, if you are creating your own custom composable that is wrapping `useAsyncData`.

自動生成されたキーは、`useAsyncData` が呼び出されるファイルと行のみを考慮するため、`useAsyncData` をラップする独自のカスタム コンポーザブルを作成する場合は、望ましくない動作を避けるために常に独自のキーを作成することをお勧めします。

```ts
const id = ref(1)

const { data, error } = await useAsyncData(`user:${id.value}`, () => {
  return myGetFunction('users', { id: id.value })
})
```

> The `useAsyncData` composable is a great way to wrap and wait for multiple `useFetch` to be done, and then retrieve the results of each.

`useAsyncData` コンポーザブルは、複数の `useFetch` が実行されるまでラップして待機し、それぞれの結果を取得するための優れた方法です。

```ts
const { data: discounts, pending } = await useAsyncData('cart-discount', async () => {
  const [coupons, offers] = await Promise.all([$fetch('/cart/coupons'), $fetch('/cart/offers')])

  return {
    coupons,
    offers
  }
})
```

[ReadMore](https://nuxt.com/docs/api/composables/use-async-data)

## Options

> [`useAsyncData`](/docs/api/composables/use-async-data) and [`useFetch`](/docs/api/composables/use-fetch) return the same object type and accept a common set of options as their last argument. They can help you control the composables behavior, such as navigation blocking, caching or execution.

[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) と [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) は同じオブジェクト タイプを返し、共通のオプション セットを受け入れます。 彼らの最後の議論。 これらは、ナビゲーションのブロック、キャッシュ、実行などのコンポーザブルの動作を制御するのに役立ちます。

### Lazy

> By default, data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue’s Suspense. This feature can be ignored on client-side navigation with the `lazy` option. In that case, you will have to manually handle loading state using the `pending` value.

デフォルトでは、データをフェッチするコンポーザブルは、Vue の Suspense を使用して新しいページに移動する前に、非同期関数の解決を待機します。 この機能は、「lazy」オプションを使用したクライアント側ナビゲーションでは無視できます。 その場合、「pending」値を使用して読み込み状態を手動で処理する必要があります。

```vue [app.vue]
<script setup lang="ts">
const { pending, data: posts } = useFetch('/api/posts', {
  lazy: true
})
</script>

<template>
  <!-- you will need to handle a loading state -->
  <div v-if="pending">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

> You can alternatively use [`useLazyFetch`](/docs/api/composables/use-lazy-fetch) and `useLazyAsyncData` as convenient methods to perform the same.

代わりに、同じことを実行する便利なメソッドとして [`useLazyFetch`](/docs/api/composables/use-lazy-fetch) と `useLazyAsyncData` を使用することもできます。

```ts
const { pending, data: posts } = useLazyFetch('/api/posts')
```

[ReadMore](https://nuxt.com/docs/api/composables/use-lazy-fetch]

[ReadMore](https://nuxt.com/docs/api/composables/use-lazy-async-data]

### Client-only fetching

> By default, data fetching composables will perform their asynchronous function on both client and server environments. Set the `server` option to `false` to only perform the call on the client-side. On initial load, the data will not be fetched before hydration is complete so you have to handle a pending state, though on subsequent client-side navigation the data will be awaited before loading the page.

デフォルトでは、データフェッチコンポーザブルはクライアント環境とサーバー環境の両方で非同期機能を実行します。 クライアント側でのみ呼び出しを実行するには、「server」オプションを「false」に設定します。 初期ロードでは、ハイドレーションが完了する前にデータがフェッチされないため、保留状態を処理する必要がありますが、その後のクライアント側のナビゲーションでは、ページをロードする前にデータが待機されます。

> Combined with the `lazy` option, this can be useful for data that is not needed on the first render (for example, non-SEO sensitive data).

「lazy」オプションと組み合わせると、最初のレンダリングでは必要のないデータ (SEO に依存しないデータなど) に役立ちます。

```ts
/* This call is performed before hydration */
const { article } = await useFetch('api/article')

/* This call will only be performed on the client */
const { pending, data: posts } = useFetch('/api/comments', {
  lazy: true,
  server: false
})
```

> The `useFetch` composable is meant to be invoked in setup method or called directly at the top level of a function in lifecycle hooks, otherwise you should use [`$fetch` method](#fetch).

`useFetch` コンポーザブルは、setup メソッドで呼び出すか、ライフサイクル フックの関数の最上位で直接呼び出すことを目的としています。それ以外の場合は、[`$fetch` メソッド](#fetch) を使用する必要があります。

### Minimize payload size

> The `pick` option helps you to minimize the payload size stored in your HTML document by only selecting the fields that you want returned from the composables.

「pick」オプションを使用すると、コンポーザブルから返したいフィールドのみを選択することで、HTML ドキュメントに保存されるペイロード サイズを最小限に抑えることができます。

```vue
<script setup lang="ts">
/* only pick the fields used in your template */
const { data: mountain } = await useFetch('/api/mountains/everest', { pick: ['title', 'description'] })
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

> If you need more control or map over several objects, you can use the `transform` function to alter the result of the query.

複数のオブジェクトをより詳細に制御またはマップする必要がある場合は、「transform」関数を使用してクエリの結果を変更できます。

```ts
const { data: mountains } = await useFetch('/api/mountains', { 
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  }
})
```

> Both `pick` and `transform` don't prevent the unwanted data from being fetched initially. But they will prevent unwanted data from being added to the payload transferred from server to client.

`pick` と `transform` はどちらも、最初に不要なデータがフェッチされるのを妨げません。 ただし、サーバーからクライアントに転送されるペイロードに不要なデータが追加されるのを防ぎます。

### Caching and refetching

#### Keys

[`useFetch`](/docs/api/composables/use-fetch) and [`useAsyncData`](/docs/api/composables/use-async-data) use keys to prevent refetching the same data.

> [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) と [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) はキーを使用して、同じデータの再フェッチを防ぎます。

> - [`useFetch`](/docs/api/composables/use-fetch) uses the provided URL as a key. Alternatively, a `key` value can be provided in the `options` object passed as a last argument.
> - [`useAsyncData`](/docs/api/composables/use-async-data) uses its first argument as a key if it is a string. If the first argument is the handler function that performs the query, then a key that is unique to the file name and line number of the instance of `useAsyncData` will be generated for you.

- [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) は、指定された URL をキーとして使用します。 あるいは、最後の引数として渡される「options」オブジェクトに「key」値を指定することもできます。
- [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) は、最初の引数が文字列の場合、キーとして使用します。 最初の引数がクエリを実行するハンドラー関数である場合、`useAsyncData` のインスタンスのファイル名と行番号に固有のキーが生成されます。

> To get the cached data by key, you can use [`useNuxtData`](/docs/api/composables/use-nuxt-data)

キャッシュされたデータをキーで取得するには、[`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data) を使用できます。

#### Refresh and execute 更新して実行

If you want to fetch or refresh data manually, use the `execute` or `refresh` function provided by the composables.

> データを手動でフェッチまたはリフレッシュする場合は、コンポーザブルによって提供される「実行」または「リフレッシュ」関数を使用します。

```vue
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="refresh">Refresh data</button>
  </div>
</template>
```

> The `execute` function is an alias for `refresh` that works in exactly the same way but is more semantic for cases when the fetch is [not immediate](#not-immediate).

`execute` 関数は `refresh` のエイリアスで、まったく同じように動作しますが、フェッチが [即時ではない](#not-immediate) 場合によりセマンティックになります。

> To globally refetch or invalidate cached data, see [`clearNuxtData`](/docs/api/utils/clear-nuxt-data) and [`refreshNuxtData`](/docs/api/utils/refresh-nuxt-data).

キャッシュされたデータをグローバルに再フェッチまたは無効化するには、[`clearNuxtData`](https://nuxt.com/docs/api/utils/clear-nuxt-data) および [`refreshNuxtData`](https://nuxt.com/docs/api/utils/refresh-nuxt-data) を参照してください。

#### Watch

> To re-run your fetching function each time other reactive values in your application change, use the `watch` option. You can use it for one or multiple _watchable_ elements.

アプリケーション内の他のリアクティブな値が変更されるたびにフェッチ関数を再実行するには、`watch` オプションを使用します。 1 つまたは複数の _watchable_ 要素に使用できます。

```ts
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Changing the id will trigger a refetch */
  watch: [id]
})
```

### Not immediate

> The `useFetch` composable will start fetching data the moment is invoked. You may prevent this by setting `immediate: false`, for example, to wait for user interaction.

`useFetch` コンポーザブルは、呼び出された瞬間にデータのフェッチを開始します。 たとえば、ユーザーの操作を待つように「immediate: false」を設定することで、これを防ぐことができます。

> With that, you will need both the `status` to handle the fetch lifecycle, and `execute` to start the data fetch.

これにより、フェッチのライフサイクルを処理するための「ステータス」と、データのフェッチを開始するための「実行」の両方が必要になります。

```vue
<script setup lang="ts">
const { data, error, execute, pending, status } = await useLazyFetch('/api/comments')
</script>

<template>
  <div v-if="status === 'idle'">
    <button @click="execute">Get data</button>
  </div>

  <div v-else-if="pending">
    Loading comments...
  </div>

  <div v-else>
    {{ data }}
  </div>
</template>
```

> For finer control, the `status` variable can be:

より細かく制御するには、「status」変数を次のようにします。

> - `idle` when the fetch hasn't started
> - `pending` when a fetch has started but not yet completed
> - `error` when the fetch fails
> - `success` when the fetch is completed successfully

- フェッチが開始されていない場合は「アイドル」
- フェッチが開始されたがまだ完了していない場合は「pending」
- フェッチが失敗した場合の「エラー」
- `success` フェッチが正常に完了した場合

## Passing Headers and cookies ヘッダーと Cookie を渡す

> When we call `$fetch` in the browser, user headers like `cookie` will be directly sent to the API. But during server-side-rendering, since the `$fetch` request takes place 'internally' within the server, it doesn't include the user's browser cookies, nor does it pass on cookies from the fetch response.

ブラウザで `$fetch` を呼び出すと、`cookie` などのユーザー ヘッダーが API に直接送信されます。 ただし、サーバー側のレンダリング中、「$fetch」リクエストはサーバー内で「内部」で行われるため、ユーザーのブラウザの Cookie は含まれず、フェッチ応答からの Cookie も渡されません。

### Pass Client Headers to the API クライアントヘッダーを API に渡す

> We can use [`useRequestHeaders`](/docs/api/composables/use-request-headers) to access and proxy cookies to the API from server-side.

[`useRequestHeaders`](https://nuxt.com/docs/api/composables/use-request-headers) を使用して、サーバー側から Cookie にアクセスし、API にプロキシすることができます。

> The example below adds the request headers to an isomorphic `$fetch` call to ensure that the API endpoint has access to the same `cookie` header originally sent by the user.

以下の例では、リクエスト ヘッダーを同型の `$fetch` 呼び出しに追加して、API エンドポイントがユーザーによって最初に送信されたものと同じ `cookie` ヘッダーにアクセスできるようにします。

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

const { data } = await useFetch('/api/me', { headers })
</script>
```

> Be very careful before proxying headers to an external API and just include headers that you need. Not all headers are safe to be bypassed and might introduce unwanted behavior. Here is a list of common headers that are NOT to be proxied:

ヘッダーを外部 API にプロキシする前に十分に注意し、必要なヘッダーだけを含めてください。 すべてのヘッダーを安全にバイパスできるわけではなく、望ましくない動作が発生する可能性があります。 プロキシされない一般的なヘッダーのリストは次のとおりです。

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`


### Pass Cookies From Server-side API Calls on SSR Response SSR 応答でサーバー側 API 呼び出しから Cookie を渡す

> If you want to pass on/proxy cookies in the other direction, from an internal request back to the client, you will need to handle this yourself.

内部リクエストからクライアントに戻るなど、逆方向に Cookie を渡したりプロキシしたりする場合は、これを自分で処理する必要があります。

```ts [composables/fetch.ts]
import { appendResponseHeader, H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Get the response from the server endpoint */
  const res = await $fetch.raw(url)
  /* Get the cookies from the response */
  const cookies = (res.headers.get('set-cookie') || '').split(',')
  /* Attach each cookie to our incoming Request */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  /* Return the data of the response */
  return res._data
}
```

```vue
<script setup lang="ts">
// This composable will automatically pass cookies to the client
const event = useRequestEvent()

const result = await fetchWithCookie(event, '/api/with-cookie')

onMounted(() => console.log(document.cookie))
</script>
```

## Options API support オプション API のサポート

> Nuxt 3 provides a way to perform `asyncData` fetching within the Options API. You must wrap your component definition within `defineNuxtComponent` for this to work.

Nuxt 3 は、オプション API 内で「asyncData」フェッチを実行する方法を提供します。 これを機能させるには、コンポーネント定義を `defineNuxtComponent` 内にラップする必要があります。

```vue
<script>
export default defineNuxtComponent({
  /* Use the fetchKey option to provide a unique key */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello')
    }
  }
})
</script>
```

> Using `<script setup lang="ts">` is the recommended way of declaring Vue components in Nuxt 3.

Nuxt 3 で Vue コンポーネントを宣言するには、`<script setup lang="ts">` を使用することをお勧めします。

[ReadMore](https://nuxt.com/docs/api/utils/define-nuxt-component)


## Serialization

> When fetching data from the `server` directory, the response is serialized using `JSON.stringify`. However, since serialization is limited to only JavaScript primitive types, Nuxt does its best to convert the return type of `$fetch` and [`useFetch`](/docs/api/composables/use-fetch) to match the actual value.

「server」ディレクトリからデータを取得するとき、応答は「JSON.stringify」を使用してシリアル化されます。 ただし、シリアル化は JavaScript のプリミティブ型のみに制限されているため、Nuxt は `$fetch` と [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) の戻り値の型を実際の値と一致するように変換するよう最善を尽くします。

> You can learn more about `JSON.stringify` limitations [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description).

「JSON.stringify」の制限について詳しくは、[こちら](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description) をご覧ください。

### Example

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app.vue]
<script setup lang="ts">
// Type of `data` is inferred as string even though we returned a Date object
const { data } = await useFetch('/api/foo')
</script>
```

### Custom serializer function カスタムシリアライザー機能

> To customize the serialization behavior, you can define a `toJSON` function on your returned object. If you define a `toJSON` method, Nuxt will respect the return type of the function and will not try to convert the types.

シリアル化の動作をカスタマイズするには、返されたオブジェクトに `toJSON` 関数を定義できます。 「toJSON」メソッドを定義すると、Nuxt は関数の戻り値の型を尊重し、型の変換を試みません。

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON() {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})

```

```vue [app.vue]
<script setup lang="ts">
// Type of `data` is inferred as
// {
//   createdAt: {
//     year: number
//     month: number
//     day: number
//   }
// }
const { data } = await useFetch('/api/bar')
</script>
```

### Using an alternative serializer 代替シリアライザーの使用

Nuxt does not currently support an alternative serializer to `JSON.stringify`. However, you can return your payload as a normal string and utilize the `toJSON` method to maintain type safety.

Nuxt は現在、「JSON.stringify」の代替シリアライザーをサポートしていません。 ただし、ペイロードを通常の文字列として返し、「toJSON」メソッドを使用してタイプ セーフを維持することができます。

In the example below, we use [superjson](https://github.com/blitz-js/superjson) as our serializer.

以下の例では、シリアライザーとして [superjson](https://github.com/blitz-js/superjson) を使用します。

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Workaround the type conversion
    toJSON() {
      return this
    }
  }

  // Serialize the output to string, using superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `date` is inferred as { createdAt: Date } and you can safely use the Date object methods
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```
