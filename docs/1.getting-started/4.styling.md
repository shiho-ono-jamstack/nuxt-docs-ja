---
navigation.icon: uil:palette
---

# Styling

> Nuxt is highly flexible when it comes to styling. Write your own styles, or reference local and external stylesheets.
You can use CSS preprocessors, CSS frameworks, UI libraries and Nuxt modules to style your application.

Nuxt はスタイリングに関して非常に柔軟です。 独自のスタイルを作成するか、ローカルおよび外部のスタイルシートを参照します。
CSS プリプロセッサ、CSS フレームワーク、UI ライブラリ、Nuxt モジュールを使用してアプリケーションのスタイルを設定できます。

## Local Stylesheets

> If you're writing local stylesheets, the natural place to put them is the [`assets/` directory](/docs/guide/directory-structure/assets).

ローカル スタイルシートを作成している場合、それらを配置する自然な場所は [`assets/` ディレクトリ](/docs/guide/directory-structor/assets) です。

### Importing Within Components

> You can import stylesheets in your pages, layouts and components directly.
You can use a javascript import, or a css [`@import` statement](https://developer.mozilla.org/en-US/docs/Web/CSS/@import).

ページ、レイアウト、コンポーネントにスタイルシートを直接インポートできます。
JavaScript インポートまたは CSS [`@import` ステートメント](https://developer.mozilla.org/en-US/docs/Web/CSS/@import) を使用できます。

```vue [pages/index.vue]
<script>
// Use a static import for server-side compatibility
import '~/assets/css/first.css'

// Caution: Dynamic imports are not server-side compatible
import('~/assets/css/first.css')
</script>

<style>
@import url("~/assets/css/second.css");
</style>
```

> **Note**  
> The stylesheets will be inlined in the HTML rendered by Nuxt.


スタイルシートは、Nuxt によってレンダリングされる HTML にインライン化されます。

### The CSS Property

> You can also use the `css` property in the Nuxt configuration.
> The natural place for your stylesheets is the [`assets/` directory](/docs/guide/directory-structure/assets). You can then reference its path and Nuxt will include it to all the pages of your application.

Nuxt 設定で「css」プロパティを使用することもできます。
スタイルシートの自然な場所は [`assets/` ディレクトリ](/docs/guide/directory- Structure/assets) です。 その後、そのパスを参照すると、Nuxt はそのパスをアプリケーションのすべてのページに含めます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['~/assets/css/main.css']
})
```

> **Note**
> The stylesheets will be inlined in the HTML rendered by Nuxt, injected globally and present in all pages.

スタイルシートは、Nuxt によってレンダリングされる HTML にインライン化され、グローバルに挿入され、すべてのページに存在します。

### Working With Fonts

> Place your local fonts files in your `~/public/` directory, for example in `~/public/fonts`. You can then reference them in your stylesheets using `url()`.

ローカル フォント ファイルを `~/public/` ディレクトリ (たとえば `~/public/fonts`) に置きます。 その後、「url()」を使用してスタイルシート内でそれらを参照できます。

```css [assets/css/main.css]
@font-face {
  font-family: 'FarAwayGalaxy';
  src: url('/fonts/FarAwayGalaxy.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
```

> Then reference your fonts by name in your stylesheets, pages or components:

次に、スタイルシート、ページ、またはコンポーネントでフォントを名前で参照します。

```vue
<style>
h1 {
  font-family: 'FarAwayGalaxy', sans-serif;
}
</style>
```

### Stylesheets Distributed Through NPM

> You can also reference stylesheets that are distributed through npm. Let's use the popular `animate.css` library as an example.

npm を通じて配布されるスタイルシートを参照することもできます。 例として、人気のある「animate.css」ライブラリを使用してみましょう。

```bash
npm install animate.css
```

> Then you can reference it directly in your pages, layouts and components:

その後、ページ、レイアウト、コンポーネントで直接参照できます。

```vue [app.vue]
<script>
import 'animate.css'
</script>

<style>
@import url("animate.css");
</style>
```

> The package can also be referenced as a string in the css property of your Nuxt configuration.

パッケージは、Nuxt 設定の css プロパティ内の文字列として参照することもできます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['animate.css']
})
```

## External Stylesheets

> You can include external stylesheets in your application by adding a link element in the head section of your nuxt.config file. You can achieve this result using different methods. Note that local stylesheets can also be included like this.

nuxt.config ファイルの head セクションに link 要素を追加することで、アプリケーションに外部スタイルシートを含めることができます。 さまざまな方法を使用してこの結果を達成できます。 このようにローカル スタイルシートも含めることができることに注意してください。

> You can manipulate the head with the [`app.head`](/docs/api/configuration/nuxt-config#head) property of your Nuxt configuration:

Nuxt 設定の [`app.head`](/docs/api/configuration/nuxt-config#head) プロパティを使用してヘッドを操作できます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    head: {
      link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]
    }
}})
```

### Dynamically Adding Stylesheets スタイルシートを動的に追加する

> You can use the useHead composable to dynamically set a value in your head in your code.

useHead コンポーザブルを使用すると、コード内の頭に値を動的に設定できます。

[ReadMore](/docs/api/composables/use-head)

```ts
useHead({
  link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]
})
```

> Nuxt uses `unhead` under the hood, and you can refer to its full documentation [here](https://unhead.unjs.io/).

Nuxt は内部で「unhead」を使用しており、その完全なドキュメントは [ここ](https://unhead.unjs.io/) で参照できます。

### Modifying The Rendered Head With A Nitro Plugin

> If you need more advanced control, you can intercept the rendered html with a hook and modify the head programmatically.

より高度な制御が必要な場合は、レンダリングされた HTML をフックでインターセプトし、プログラムでヘッドを変更できます。

> Create a plugin in `~/server/plugins/my-plugin.ts` like this:

次のように `~/server/plugins/my-plugin.ts` にプラグインを作成します。

```ts [server/plugins/my-plugin.ts]
export default defineNitroPlugin((nitro) => {
  nitro.hooks.hook('render:html', (html) => {
    html.head.push('<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">')
  })
})
```

> External stylesheets are render-blocking resources: they must be loaded and processed before the browser renders the page. Web pages that contain unnecessarily large styles take longer to render. You can read more about it on [web.dev](https://web.dev/defer-non-critical-css/).

外部スタイルシートはレンダリングをブロックするリソースです。ブラウザがページをレンダリングする前に、外部スタイルシートをロードして処理する必要があります。 不必要に大きなスタイルを含む Web ページは、レンダリングに時間がかかります。 詳細については、[web.dev](https://web.dev/defer-non-critical-css/) で読むことができます。

## Using Preprocessors プリプロセッサの使用

> To use a preprocessor like SCSS, Sass, Less or Stylus, install it first.

SCSS、Sass、Less、Stylus などのプリプロセッサを使用するには、まずそれをインストールします。


```bash [Sass & SCSS]
npm install sass
```

```bash [Less]
npm install less
```

```bash [Stylus]
npm install stylus
```

The natural place to write your stylesheets is the `assets` directory.
You can then import your source files in your `app.vue` (or layouts files) using your preprocessor's syntax.

> スタイルシートを記述するのに自然な場所は「assets」ディレクトリです。
その後、プリプロセッサの構文を使用してソース ファイル (またはレイアウト ファイル) を「app.vue」にインポートできます。

```vue [pages/app.vue]
<style lang="scss">
@use "~/assets/scss/main.scss";
</style>
```

> Alternatively, you can use the `css` property of your Nuxt configuration.

あるいは、Nuxt 設定の「css」プロパティを使用することもできます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['~/assets/scss/main.scss']
})
```

> **Note**  
> In both cases, the compiled stylesheets will be inlined in the HTML rendered by Nuxt.

どちらの場合も、コンパイルされたスタイルシートは、Nuxt によってレンダリングされる HTML にインライン化されます。

> If you need to inject code in pre-processed files, like a [sass partial](https://sass-lang.com/documentation/at-rules/use#partials) with color variables, you can do so with the vite [preprocessors options](https://vitejs.dev/config/shared-options.html#css-preprocessoroptions).

カラー変数を含む [sass パーシャル](https://sass-lang.com/documentation/at-rules/use#partials) など、前処理されたファイルにコードを挿入する必要がある場合は、vite を使用して行うことができます。 [プリプロセッサ オプション](https://vitejs.dev/config/shared-options.html#css-preprocessoroptions)。

> Create some partials in your `assets` directory:

`assets` ディレクトリにいくつかのパーシャルを作成します。



```scss [assets/_colors.scss]
$primary: #49240F;
$secondary: #E4A79D;
```

```sass [assets/_colors.sass]
$primary: #49240F
$secondary: #E4A79D
```

Then in your `nuxt.config` :


```ts [SCSS]
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: '@use "@/assets/_colors.scss" as *;'
        }
      }
    }
  }
})
```

```ts [SASS]
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        sass: {
          additionalData: '@use "@/assets/_colors.sass" as *\n'
        }
      }
    }
  }
})
```

> Nuxt uses Vite by default. If you wish to use webpack instead, refer to each preprocessor loader [documentation](https://webpack.js.org/loaders/sass-loader/).

Nuxt はデフォルトで Vite を使用します。 代わりに webpack を使用したい場合は、各プリプロセッサ ローダー [ドキュメント](https://webpack.js.org/loaders/sass-loader/) を参照してください。

## Single File Components (SFC) Styling

> One of the best thing about Vue and SFC is how great it is at naturally dealing with styling. You can directly write CSS or preprocessor code in the style block of your components file, therefore you will have fantastic developer experience without having to use something like CSS-in-JS. However if you wish to use CSS-in-JS, you can find 3rd party libraries and modules that support it, such as [pinceau](https://pinceau.dev/).

Vue と SFC の最も優れている点の 1 つは、スタイルを自然に処理できる点にあります。 コンポーネント ファイルのスタイル ブロックに CSS またはプリプロセッサ コードを直接記述することができるため、CSS-in-JS などを使用しなくても、素晴らしい開発エクスペリエンスを得ることができます。 ただし、CSS-in-JS を使用したい場合は、[pinceau](https://pinceau.dev/) など、それをサポートするサードパーティのライブラリとモジュールを見つけることができます。

> You can refer to the [Vue docs](https://vuejs.org/api/sfc-css-features.html) for a comprehensive reference about styling components in SFC.

SFC のコンポーネントのスタイル設定に関する包括的なリファレンスについては、[Vue ドキュメント](https://vuejs.org/api/sfc-css-features.html) を参照してください。

### Class And Style Bindings

> You can leverage Vue SFC features to style your components with class and style attributes.

Vue SFC 機能を利用して、クラス属性とスタイル属性を使用してコンポーネントをスタイル設定できます。


```vue [Ref and Reactive]
<script setup lang="ts">
const isActive = ref(true)
const hasError = ref(false)
const classObject = reactive({
  active: true,
  'text-danger': false
})
</script>

<template>
  <div class="static" :class="{ active: isActive, 'text-danger': hasError }"></div>
  <div :class="classObject"></div>
</template>
```

```vue [Computed]
<script setup lang="ts">
const isActive = ref(true)
const error = ref(null)

const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))
</script>

<template>
  <div :class="classObject"></div>
</template>
```

```vue [Array]
<script setup lang="ts"> 
const isActive = ref(true)
const errorClass = ref('text-danger')
</script>

<template>
  <div :class="[{ active: isActive }, errorClass]"></div>
</template>
```

```vue [Style]
<script setup lang="ts">
const activeColor = ref('red')
const fontSize = ref(30)
const styleObject = reactive({ color: 'red', fontSize: '13px' })
</script>

<template>
  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
  <div :style="[baseStyles, overridingStyles]"></div>
  <div :style="styleObject"></div>
</template>
```

> Refer to the [Vue docs](https://vuejs.org/guide/essentials/class-and-style.html) for more information.

詳細については、[Vue ドキュメント](https://vuejs.org/guide/essentials/class-and-style.html) を参照してください。

### Dynamic Styles With `v-bind`

> You can reference JavaScript variable and expression within your style blocks with the v-bind function.
> The binding will be dynamic, meaning that if the variable value changes, the style will be updated.

v-bind 関数を使用すると、スタイル ブロック内の JavaScript 変数と式を参照できます。  
バインディングは動的になります。つまり、変数値が変更されるとスタイルも更新されます。

```vue
<script setup lang="ts">
const color = ref("red")
</script>

<template>
  <div class="text">hello</div>
</template>

<style>
.text {
  color: v-bind(color);
}
</style>
```

### Scoped Styles

> The scoped attribute allows you to style component in insolation. The styles declared with this attribute will only apply to this component.

スコープ付き属性を使用すると、日射量でコンポーネントをスタイル設定できます。この属性で宣言されたスタイルは、このコンポーネントにのみ適用されます。

```vue
<template>
  <div class="example">hi</div>
</template>

<style scoped>
.example {
  color: red;
}
</style>
```

### CSS Modules

> You can use [CSS Modules](https://github.com/css-modules/css-modules) with the module attribute. Access it with the injected `$style` variable.

[CSS モジュール](https://github.com/css-modules/css-modules) を module 属性とともに使用できます。 挿入された `$style` 変数を使用してアクセスします。

```vue
<template>
  <p :class="$style.red">This should be red</p>
</template>

<style module>
.red {
  color: red;
}
</style>
```

### Preprocessors Support

> SFC style blocks support preprocessors syntax. Vite come with built-in support for .scss, .sass, .less, .styl and .stylus files without configuration. You just need to install them first, and they will be available directly in SFC with the lang attribute.

SFC スタイル ブロックは、プリプロセッサ構文をサポートします。 Vite には、設定なしで .scss、.sass、.less、.styl、.stylus ファイルのサポートが組み込まれています。 最初にこれらをインストールするだけで、lang 属性を使用して SFC で直接使用できるようになります。


```vue [SCSS]
<style lang="scss">
  /* Write scss here */
</style>
```

```vue [Sass]
<style lang="sass">
  /* Write sass here */
</style>
```

```vue [LESS]
<style lang="less">
  /* Write less here */
</style>
```

```vue [Stylus]
<style lang="stylus">
  /* Write stylus here */
</style>
```


> You can refer to the [Vite CSS docs](https://vitejs.dev/guide/features.html#css) and the [@vitejs/plugin-vue docs](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue).
> For webpack users, refer to the [vue loader docs](https://vue-loader.vuejs.org/).

[Vite CSS ドキュメント](https://vitejs.dev/guide/features.html#css) および [@vitejs/plugin-vue ドキュメント](https://github.com/vitejs/vite) を参照してください。 -plugin-vue/tree/main/packages/plugin-vue)。
Webpack ユーザーについては、[vue ローダーのドキュメント](https://vue-loader.vuejs.org/) を参照してください。

## Using PostCSS

Nuxt comes with postcss built-in. You can configure it in your `nuxt.config` file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  postcss: {
    plugins: {
      'postcss-nested': {}
      "postcss-custom-media": {}
    }
  }
})
```

> For proper syntax highlighting in SFC, you can use the postcss lang attribute.

SFC で構文を適切に強調表示するには、postcss lang 属性を使用できます。

```vue
<style lang="postcss">
  /* Write stylus here */
</style>
```

By default, Nuxt comes with the following plugins already pre-configured:

- [postcss-import](https://github.com/postcss/postcss-import): Improves the `@import` rule
- [postcss-url](https://github.com/postcss/postcss-url): Transforms `url()` statements
- [autoprefixer](https://github.com/postcss/autoprefixer): Automatically adds vendor prefixes
- [cssnano](https://cssnano.co/): Minification and purge

##  Leveraging Layouts For Multiple Styles

> If you need to style different parts of your application completely differently, you can use layouts.
Use different styles for different layouts.

アプリケーションのさまざまな部分をまったく異なるスタイルにする必要がある場合は、レイアウトを使用できます。
レイアウトごとに異なるスタイルを使用します。

```vue
<template>
  <div class="default-layout">
    <h1>Default Layout</h1>
    <slot />
  </div>
</template>

<style>
.default-layout {
  color: red;
}
</style>
```

[ReadMore](/docs/guide/directory-structure/layouts)

## Third Party Libraries And Modules サードパーティのライブラリとモジュール

> Nuxt isn't opinionated when it comes to styling and provides you with a wide variety of options. You can use any styling tool that you want, such as popular libraries like [UnoCSS](https://unocss.dev/) or [Tailwind CSS](https://tailwindcss.com/).

Nuxt はスタイルに関して独自の意見を持たず、幅広いオプションを提供します。 [UnoCSS](https://unocss.dev/) や [Tailwind CSS](https://tailwindcss.com/) などの一般的なライブラリなど、必要なスタイリング ツールを使用できます。

> The community and the Nuxt team have developed plenty of Nuxt modules to makes the integration easier.
> You can discover them on the [modules section](https://nuxt.com/modules) of the website.
> Here are a few modules to help you get started:

コミュニティと Nuxt チームは、統合を容易にするために多くの Nuxt モジュールを開発しました。
これらは、Web サイトの [モジュール セクション](https://nuxt.com/modules) で見つけることができます。
開始に役立ついくつかのモジュールを次に示します。

- [UnoCSS](https://nuxt.com/modules/unocss): Instant on-demand atomic CSS engine
- [Tailwind CSS](https://nuxt.com/modules/tailwindcss): Utility-first CSS framework
- [Fontaine](https://github.com/nuxt-modules/fontaine): Font metric fallback
- [Pinceau](https://pinceau.dev/): Adaptable styling framework
- [Nuxt UI](https://ui.nuxt.com): A UI Library for Modern Web Apps

> Nuxt modules provide you with a good developer experience out of the box, but remember that if your favorite tool doesn't have a module, it doesn't mean that you can't use it with Nuxt! You can configure it yourself for your own project. Depending on the tool, you might need to use a [Nuxt plugin](/docs/guide/directory-structure/plugins) and/or [make your own module](/docs/guide/going-further/modules). Share them with the [community](https://nuxt.com/modules) if you do!

Nuxt モジュールはすぐに優れた開発者エクスペリエンスを提供しますが、お気に入りのツールにモジュールがないからといって、それを Nuxt で使用できないわけではないことに注意してください。 独自のプロジェクトに合わせて自分で設定できます。 ツールによっては、[Nuxt プラグイン](/docs/guide/directory- Structure/plugins) および/または [独自のモジュールの作成](/docs/guide/getting-further/modules) を使用する必要がある場合があります。 必要に応じて、[コミュニティ](https://nuxt.com/modules) で共有してください。

### Easily Load Webfonts Webフォントを簡単にロード

> You can use [the Nuxt Google Fonts module](https://github.com/nuxt-modules/google-fonts) to load Google Fonts.

[Nuxt Google Fonts モジュール](https://github.com/nuxt-modules/google-fonts) を使用して Google Fonts をロードできます。

> If you are using [UnoCSS](https://unocss.dev/integrations/nuxt), note that it comes with a [web fonts presets](https://unocss.dev/presets/web-fonts) to conveniently load fonts from common providers, including Google Fonts and more.

[UnoCSS](https://unocss.dev/integrations/nuxt) を使用している場合は、便利にロードするための [Web フォント プリセット](https://unocss.dev/presets/web-fonts) が付属していることに注意してください。 Google Fonts などの一般的なプロバイダーのフォント。

## Advanced

### Transitions

> Nuxt comes with the same `<Transition>` element that Vue has, and also has support for the experimental [View Transitions API](/docs/getting-started/transitions#view-transitions-api-experimental).

Nuxt には Vue と同じ `<Transition>` 要素が付属しており、実験的な [View Transitions API](/docs/getting-started/transitions#view-transitions-api-experimental) もサポートしています。

[ReadMore](/docs/features/transitions)

### Font Advanced Optimization フォントの高度な最適化

> We would recommend using [Fontaine](https://github.com/nuxt-modules/fontaine) to reduce your [CLS](https://web.dev/cls/). If you need something more advanced, consider creating a Nuxt module to extend the build process or the Nuxt runtime.

[CLS](https://web.dev/cls/) を削減するには、[Fontaine](https://github.com/nuxt-modules/fontaine) を使用することをお勧めします。 より高度な機能が必要な場合は、Nuxt モジュールを作成してビルド プロセスまたは Nuxt ランタイムを拡張することを検討してください。

::alert{type="info"}
Always remember to take advantage of the various tools and techniques available in the Web ecosystem at large to make styling your application easier and more efficient. Whether you're using native CSS, a preprocessor, postcss, a UI library or a module, Nuxt has got you covered. Happy styling!
::

> **Note**  
> アプリケーションのスタイルをより簡単かつ効率的にするために、Web エコシステム全体で利用可能なさまざまなツールやテクニックを常に活用することを忘れないでください。 ネイティブ CSS、プリプロセッサ、postcss、UI ライブラリ、モジュールのいずれを使用している場合でも、Nuxt が対応します。 ハッピースタイリング！

### LCP Advanced optimizations LCP の高度な最適化

> You can do the following to speed-up the download of your global CSS files:

次の手順を実行すると、グローバル CSS ファイルのダウンロードを高速化できます。

> - Use a CDN so the files are physically closer to your users
> - Compress your assets, ideally using Brotli
> - Use HTTP2/HTTP3 for delivery
> - Host your assets on the same domain (do not use a different subdomain)

- CDN を使用して、ファイルが物理的にユーザーに近づくようにします
- 理想的には Brotli を使用してアセットを圧縮します
- 配信にはHTTP2/HTTP3を使用します
- 同じドメインでアセットをホストします (別のサブドメインを使用しないでください)

> Most of these things should be done for you automatically if you're using modern platforms like Cloudflare, Netlify or Vercel.
You can find an LCP optimization guide on [web.dev](https://web.dev/optimize-lcp/).

Cloudflare、Netlify、Vercel などの最新のプラットフォームを使用している場合、これらの作業のほとんどは自動的に行われます。
LCP 最適化ガイドは [web.dev](https://web.dev/optimize-lcp/) で見つけることができます。

> If all of your CSS is inlined by Nuxt, you can (experimentally) completely stop external CSS files from being referenced in your rendered HTML.
You can achieve that with a hook, that you can place in a module, or in your Nuxt configuration file.

すべての CSS が Nuxt によってインライン化されている場合、レンダリングされた HTML 内で外部 CSS ファイルが参照されるのを (実験的に) 完全に停止できます。
これは、モジュールまたは Nuxt 設定ファイルに配置できるフックを使用して実現できます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'build:manifest': (manifest) => {
      // find the app entry, css list
      const css = manifest['node_modules/nuxt/dist/app/entry.js']?.css
      if (css) {
        // start from the end of the array and go to the beginning
        for (let i = css.length - 1; i >= 0; i--) {
          // if it starts with 'entry', remove it from the list
          if (css[i].startsWith('entry')) css.splice(i, 1)
        }
      }
    },
  },
})
```
