---
navigation.icon: uil:palette
---

# Styling

> Nuxt is highly flexible when it comes to styling. Write your own styles, or reference local and external stylesheets.
You can use CSS preprocessors, CSS frameworks, UI libraries and Nuxt modules to style your application.

Nuxt はスタイリングに関して非常に柔軟です。 独自のスタイルを作成するか、ローカルおよび外部のスタイルシートを参照します。
CSS プリプロセッサ、CSS フレームワーク、UI ライブラリ、Nuxt モジュールを使用してアプリケーションのスタイルを設定できます。

## Local Stylesheets

> If you're writing local stylesheets, the natural place to put them is the [`assets/` directory](/docs/guide/directory-structure/assets).

ローカル スタイルシートを作成している場合、それらを配置する自然な場所は [`assets/` ディレクトリ](/docs/guide/directory-structor/assets) です。

### Importing Within Components

> You can import stylesheets in your pages, layouts and components directly.
You can use a javascript import, or a css [`@import` statement](https://developer.mozilla.org/en-US/docs/Web/CSS/@import).

ページ、レイアウト、コンポーネントにスタイルシートを直接インポートできます。
JavaScript インポートまたは CSS [`@import` ステートメント](https://developer.mozilla.org/en-US/docs/Web/CSS/@import) を使用できます。

```vue [pages/index.vue]
<script>
// Use a static import for server-side compatibility
import '~/assets/css/first.css'

// Caution: Dynamic imports are not server-side compatible
import('~/assets/css/first.css')
</script>

<style>
@import url("~/assets/css/second.css");
</style>
```

> **Note**  
> The stylesheets will be inlined in the HTML rendered by Nuxt.


スタイルシートは、Nuxt によってレンダリングされる HTML にインライン化されます。

### The CSS Property

> You can also use the `css` property in the Nuxt configuration.
> The natural place for your stylesheets is the [`assets/` directory](/docs/guide/directory-structure/assets). You can then reference its path and Nuxt will include it to all the pages of your application.

Nuxt 設定で「css」プロパティを使用することもできます。
スタイルシートの自然な場所は [`assets/` ディレクトリ](/docs/guide/directory- Structure/assets) です。 その後、そのパスを参照すると、Nuxt はそのパスをアプリケーションのすべてのページに含めます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['~/assets/css/main.css']
})
```

> **Note**
> The stylesheets will be inlined in the HTML rendered by Nuxt, injected globally and present in all pages.

スタイルシートは、Nuxt によってレンダリングされる HTML にインライン化され、グローバルに挿入され、すべてのページに存在します。

### Working With Fonts

> Place your local fonts files in your `~/public/` directory, for example in `~/public/fonts`. You can then reference them in your stylesheets using `url()`.

ローカル フォント ファイルを `~/public/` ディレクトリ (たとえば `~/public/fonts`) に置きます。 その後、「url()」を使用してスタイルシート内でそれらを参照できます。

```css [assets/css/main.css]
@font-face {
  font-family: 'FarAwayGalaxy';
  src: url('/fonts/FarAwayGalaxy.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
```

> Then reference your fonts by name in your stylesheets, pages or components:

次に、スタイルシート、ページ、またはコンポーネントでフォントを名前で参照します。

```vue
<style>
h1 {
  font-family: 'FarAwayGalaxy', sans-serif;
}
</style>
```

### Stylesheets Distributed Through NPM

> You can also reference stylesheets that are distributed through npm. Let's use the popular `animate.css` library as an example.

npm を通じて配布されるスタイルシートを参照することもできます。 例として、人気のある「animate.css」ライブラリを使用してみましょう。

```bash
npm install animate.css
```

> Then you can reference it directly in your pages, layouts and components:

その後、ページ、レイアウト、コンポーネントで直接参照できます。

```vue [app.vue]
<script>
import 'animate.css'
</script>

<style>
@import url("animate.css");
</style>
```

> The package can also be referenced as a string in the css property of your Nuxt configuration.

パッケージは、Nuxt 設定の css プロパティ内の文字列として参照することもできます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['animate.css']
})
```

## External Stylesheets

> You can include external stylesheets in your application by adding a link element in the head section of your nuxt.config file. You can achieve this result using different methods. Note that local stylesheets can also be included like this.

nuxt.config ファイルの head セクションに link 要素を追加することで、アプリケーションに外部スタイルシートを含めることができます。 さまざまな方法を使用してこの結果を達成できます。 このようにローカル スタイルシートも含めることができることに注意してください。

> You can manipulate the head with the [`app.head`](/docs/api/configuration/nuxt-config#head) property of your Nuxt configuration:

Nuxt 設定の [`app.head`](/docs/api/configuration/nuxt-config#head) プロパティを使用してヘッドを操作できます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    head: {
      link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]
    }
}})
```

### Dynamically Adding Stylesheets スタイルシートを動的に追加する

> You can use the useHead composable to dynamically set a value in your head in your code.

useHead コンポーザブルを使用すると、コード内の頭に値を動的に設定できます。

[ReadMore](/docs/api/composables/use-head)

```ts
useHead({
  link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]
})
```

> Nuxt uses `unhead` under the hood, and you can refer to its full documentation [here](https://unhead.unjs.io/).

Nuxt は内部で「unhead」を使用しており、その完全なドキュメントは [ここ](https://unhead.unjs.io/) で参照できます。

### Modifying The Rendered Head With A Nitro Plugin

> If you need more advanced control, you can intercept the rendered html with a hook and modify the head programmatically.

より高度な制御が必要な場合は、レンダリングされた HTML をフックでインターセプトし、プログラムでヘッドを変更できます。

> Create a plugin in `~/server/plugins/my-plugin.ts` like this:

次のように `~/server/plugins/my-plugin.ts` にプラグインを作成します。

```ts [server/plugins/my-plugin.ts]
export default defineNitroPlugin((nitro) => {
  nitro.hooks.hook('render:html', (html) => {
    html.head.push('<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">')
  })
})
```

> External stylesheets are render-blocking resources: they must be loaded and processed before the browser renders the page. Web pages that contain unnecessarily large styles take longer to render. You can read more about it on [web.dev](https://web.dev/defer-non-critical-css/).

外部スタイルシートはレンダリングをブロックするリソースです。ブラウザがページをレンダリングする前に、外部スタイルシートをロードして処理する必要があります。 不必要に大きなスタイルを含む Web ページは、レンダリングに時間がかかります。 詳細については、[web.dev](https://web.dev/defer-non-critical-css/) で読むことができます。

## Using Preprocessors プリプロセッサの使用

> To use a preprocessor like SCSS, Sass, Less or Stylus, install it first.

SCSS、Sass、Less、Stylus などのプリプロセッサを使用するには、まずそれをインストールします。


```bash [Sass & SCSS]
npm install sass
```

```bash [Less]
npm install less
```

```bash [Stylus]
npm install stylus
```

The natural place to write your stylesheets is the `assets` directory.
You can then import your source files in your `app.vue` (or layouts files) using your preprocessor's syntax.

> スタイルシートを記述するのに自然な場所は「assets」ディレクトリです。
その後、プリプロセッサの構文を使用してソース ファイル (またはレイアウト ファイル) を「app.vue」にインポートできます。

```vue [pages/app.vue]
<style lang="scss">
@use "~/assets/scss/main.scss";
</style>
```

> Alternatively, you can use the `css` property of your Nuxt configuration.

あるいは、Nuxt 設定の「css」プロパティを使用することもできます。

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['~/assets/scss/main.scss']
})
```

> **Note**  
> In both cases, the compiled stylesheets will be inlined in the HTML rendered by Nuxt.

どちらの場合も、コンパイルされたスタイルシートは、Nuxt によってレンダリングされる HTML にインライン化されます。

> If you need to inject code in pre-processed files, like a [sass partial](https://sass-lang.com/documentation/at-rules/use#partials) with color variables, you can do so with the vite [preprocessors options](https://vitejs.dev/config/shared-options.html#css-preprocessoroptions).

カラー変数を含む [sass パーシャル](https://sass-lang.com/documentation/at-rules/use#partials) など、前処理されたファイルにコードを挿入する必要がある場合は、vite を使用して行うことができます。 [プリプロセッサ オプション](https://vitejs.dev/config/shared-options.html#css-preprocessoroptions)。

> Create some partials in your `assets` directory:

`assets` ディレクトリにいくつかのパーシャルを作成します。



```scss [assets/_colors.scss]
$primary: #49240F;
$secondary: #E4A79D;
```

```sass [assets/_colors.sass]
$primary: #49240F
$secondary: #E4A79D
```

Then in your `nuxt.config` :


```ts [SCSS]
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: '@use "@/assets/_colors.scss" as *;'
        }
      }
    }
  }
})
```

```ts [SASS]
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        sass: {
          additionalData: '@use "@/assets/_colors.sass" as *\n'
        }
      }
    }
  }
})
```

> Nuxt uses Vite by default. If you wish to use webpack instead, refer to each preprocessor loader [documentation](https://webpack.js.org/loaders/sass-loader/).

Nuxt はデフォルトで Vite を使用します。 代わりに webpack を使用したい場合は、各プリプロセッサ ローダー [ドキュメント](https://webpack.js.org/loaders/sass-loader/) を参照してください。

## Single File Components (SFC) Styling

> One of the best thing about Vue and SFC is how great it is at naturally dealing with styling. You can directly write CSS or preprocessor code in the style block of your components file, therefore you will have fantastic developer experience without having to use something like CSS-in-JS. However if you wish to use CSS-in-JS, you can find 3rd party libraries and modules that support it, such as [pinceau](https://pinceau.dev/).

Vue と SFC の最も優れている点の 1 つは、スタイルを自然に処理できる点にあります。 コンポーネント ファイルのスタイル ブロックに CSS またはプリプロセッサ コードを直接記述することができるため、CSS-in-JS などを使用しなくても、素晴らしい開発エクスペリエンスを得ることができます。 ただし、CSS-in-JS を使用したい場合は、[pinceau](https://pinceau.dev/) など、それをサポートするサードパーティのライブラリとモジュールを見つけることができます。

> You can refer to the [Vue docs](https://vuejs.org/api/sfc-css-features.html) for a comprehensive reference about styling components in SFC.

SFC のコンポーネントのスタイル設定に関する包括的なリファレンスについては、[Vue ドキュメント](https://vuejs.org/api/sfc-css-features.html) を参照してください。

### Class And Style Bindings

> You can leverage Vue SFC features to style your components with class and style attributes.

Vue SFC 機能を利用して、クラス属性とスタイル属性を使用してコンポーネントをスタイル設定できます。


```vue [Ref and Reactive]
<script setup lang="ts">
const isActive = ref(true)
const hasError = ref(false)
const classObject = reactive({
  active: true,
  'text-danger': false
})
</script>

<template>
  <div class="static" :class="{ active: isActive, 'text-danger': hasError }"></div>
  <div :class="classObject"></div>
</template>
```

```vue [Computed]
<script setup lang="ts">
const isActive = ref(true)
const error = ref(null)

const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))
</script>

<template>
  <div :class="classObject"></div>
</template>
```

```vue [Array]
<script setup lang="ts"> 
const isActive = ref(true)
const errorClass = ref('text-danger')
</script>

<template>
  <div :class="[{ active: isActive }, errorClass]"></div>
</template>
```

```vue [Style]
<script setup lang="ts">
const activeColor = ref('red')
const fontSize = ref(30)
const styleObject = reactive({ color: 'red', fontSize: '13px' })
</script>

<template>
  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
  <div :style="[baseStyles, overridingStyles]"></div>
  <div :style="styleObject"></div>
</template>
```

Refer to the [Vue docs](https://vuejs.org/guide/essentials/class-and-style.html) for more information.

### Dynamic Styles With `v-bind`

You can reference JavaScript variable and expression within your style blocks with the v-bind function.
The binding will be dynamic, meaning that if the variable value changes, the style will be updated.

```vue
<script setup lang="ts">
const color = ref("red")
</script>

<template>
  <div class="text">hello</div>
</template>

<style>
.text {
  color: v-bind(color);
}
</style>
```

### Scoped Styles

The scoped attribute allows you to style component in insolation. The styles declared with this attribute will only apply to this component.

```vue
<template>
  <div class="example">hi</div>
</template>

<style scoped>
.example {
  color: red;
}
</style>
```

### CSS Modules

You can use [CSS Modules](https://github.com/css-modules/css-modules) with the module attribute. Access it with the injected `$style` variable.

```vue
<template>
  <p :class="$style.red">This should be red</p>
</template>

<style module>
.red {
  color: red;
}
</style>
```

### Preprocessors Support

SFC style blocks support preprocessors syntax. Vite come with built-in support for .scss, .sass, .less, .styl and .stylus files without configuration. You just need to install them first, and they will be available directly in SFC with the lang attribute.

::code-group

```vue [SCSS]
<style lang="scss">
  /* Write scss here */
</style>
```

```vue [Sass]
<style lang="sass">
  /* Write sass here */
</style>
```

```vue [LESS]
<style lang="less">
  /* Write less here */
</style>
```

```vue [Stylus]
<style lang="stylus">
  /* Write stylus here */
</style>
```

::

You can refer to the [Vite CSS docs](https://vitejs.dev/guide/features.html#css) and the [@vitejs/plugin-vue docs](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue).
For webpack users, refer to the [vue loader docs](https://vue-loader.vuejs.org/).

## Using PostCSS

Nuxt comes with postcss built-in. You can configure it in your `nuxt.config` file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  postcss: {
    plugins: {
      'postcss-nested': {}
      "postcss-custom-media": {}
    }
  }
})
```

For proper syntax highlighting in SFC, you can use the postcss lang attribute.

```vue
<style lang="postcss">
  /* Write stylus here */
</style>
```

By default, Nuxt comes with the following plugins already pre-configured:

- [postcss-import](https://github.com/postcss/postcss-import): Improves the `@import` rule
- [postcss-url](https://github.com/postcss/postcss-url): Transforms `url()` statements
- [autoprefixer](https://github.com/postcss/autoprefixer): Automatically adds vendor prefixes
- [cssnano](https://cssnano.co/): Minification and purge

##  Leveraging Layouts For Multiple Styles

If you need to style different parts of your application completely differently, you can use layouts.
Use different styles for different layouts.

```vue
<template>
  <div class="default-layout">
    <h1>Default Layout</h1>
    <slot />
  </div>
</template>

<style>
.default-layout {
  color: red;
}
</style>
```

::ReadMore{link="/docs/guide/directory-structure/layouts"}
::

## Third Party Libraries And Modules

Nuxt isn't opinionated when it comes to styling and provides you with a wide variety of options. You can use any styling tool that you want, such as popular libraries like [UnoCSS](https://unocss.dev/) or [Tailwind CSS](https://tailwindcss.com/).

The community and the Nuxt team have developed plenty of Nuxt modules to makes the integration easier.
You can discover them on the [modules section](https://nuxt.com/modules) of the website.
Here are a few modules to help you get started:

- [UnoCSS](https://nuxt.com/modules/unocss): Instant on-demand atomic CSS engine
- [Tailwind CSS](https://nuxt.com/modules/tailwindcss): Utility-first CSS framework
- [Fontaine](https://github.com/nuxt-modules/fontaine): Font metric fallback
- [Pinceau](https://pinceau.dev/): Adaptable styling framework
- [Nuxt UI](https://ui.nuxt.com): A UI Library for Modern Web Apps

Nuxt modules provide you with a good developer experience out of the box, but remember that if your favorite tool doesn't have a module, it doesn't mean that you can't use it with Nuxt! You can configure it yourself for your own project. Depending on the tool, you might need to use a [Nuxt plugin](/docs/guide/directory-structure/plugins) and/or [make your own module](/docs/guide/going-further/modules). Share them with the [community](https://nuxt.com/modules) if you do!

### Easily Load Webfonts

You can use [the Nuxt Google Fonts module](https://github.com/nuxt-modules/google-fonts) to load Google Fonts.

If you are using [UnoCSS](https://unocss.dev/integrations/nuxt), note that it comes with a [web fonts presets](https://unocss.dev/presets/web-fonts) to conveniently load fonts from common providers, including Google Fonts and more.

## Advanced

### Transitions

Nuxt comes with the same `<Transition>` element that Vue has, and also has support for the experimental [View Transitions API](/docs/getting-started/transitions#view-transitions-api-experimental).

::ReadMore{link="/docs/features/transitions"}
::

### Font Advanced Optimization

We would recommend using [Fontaine](https://github.com/nuxt-modules/fontaine) to reduce your [CLS](https://web.dev/cls/). If you need something more advanced, consider creating a Nuxt module to extend the build process or the Nuxt runtime.

::alert{type="info"}
Always remember to take advantage of the various tools and techniques available in the Web ecosystem at large to make styling your application easier and more efficient. Whether you're using native CSS, a preprocessor, postcss, a UI library or a module, Nuxt has got you covered. Happy styling!
::

### LCP Advanced optimizations

You can do the following to speed-up the download of your global CSS files:

- Use a CDN so the files are physically closer to your users
- Compress your assets, ideally using Brotli
- Use HTTP2/HTTP3 for delivery
- Host your assets on the same domain (do not use a different subdomain)

Most of these things should be done for you automatically if you're using modern platforms like Cloudflare, Netlify or Vercel.
You can find an LCP optimization guide on [web.dev](https://web.dev/optimize-lcp/).

If all of your CSS is inlined by Nuxt, you can (experimentally) completely stop external CSS files from being referenced in your rendered HTML.
You can achieve that with a hook, that you can place in a module, or in your Nuxt configuration file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'build:manifest': (manifest) => {
      // find the app entry, css list
      const css = manifest['node_modules/nuxt/dist/app/entry.js']?.css
      if (css) {
        // start from the end of the array and go to the beginning
        for (let i = css.length - 1; i >= 0; i--) {
          // if it starts with 'entry', remove it from the list
          if (css[i].startsWith('entry')) css.splice(i, 1)
        }
      }
    },
  },
})
```
